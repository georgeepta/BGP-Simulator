import os
import psycopg2
from collections import Counter
from flask_restful import Resource, reqparse



class ASVulnerabilityRequestHandler(Resource):

    def connect_to_db(self, db_name, user, password, host, port):
        # establishing the connection
        conn = psycopg2.connect(
            database=db_name, user=user, password=password, host=host, port=port
        )

        '''
        psycopg2 is Python DB API-compliant, so the auto-commit feature is off by default. 
        We need to set conn.autocommit to True to commit any pending transaction to the database.
        '''
        conn.autocommit = True

        return conn


    def fetch_sim_results(self, simulation_uuid, conn):
        # Creating a cursor object using the cursor() method
        cursor = conn.cursor()

        # Retrieving data
        cursor.execute('''SELECT simulation_results FROM BGP_HIJACKING_SIMULATIONS WHERE simulation_id=%s''',
                       (simulation_uuid,))

        # return all rows from the table as json array
        return cursor.fetchall()[0][0]


    def fetch_AS_details(self, conn):
        # Creating a cursor object using the cursor() method
        cursor = conn.cursor()
        sql = '''SELECT * FROM ASN_TO_ORG''';
        cursor.execute(sql)
        result = cursor.fetchall()
        asns_details_dict = {}
        for row in result:
            asns_details_dict[row[0]] = row[1]
        return asns_details_dict


    def vulnerability_percentage(self, AS_counter, num_of_sims):
        if num_of_sims > 0:
            return (AS_counter/num_of_sims)*100
        else:
            return -1


    def compute_Country_vuln_ranking_after_hijack(self, sim_results, asns_details_dict, AS_vuln_list):
        print("Country Vulnerability Ranking: In Progress ...")
        AS_counter_dict = dict(Counter([item for sublist in AS_vuln_list for item in sublist]))
        AS_percentage_dict = dict(map(lambda x: (x[0], self.vulnerability_percentage(x[1], len(sim_results))), AS_counter_dict.items()))
        Country_percentage_dict = {}
        for AS in AS_percentage_dict:
            if int(AS) in asns_details_dict:
                country = asns_details_dict[int(AS)]["organizationDetails"]["country"]
                if country in Country_percentage_dict:
                    Country_percentage_dict[country].append(AS_percentage_dict[AS])
                else:
                    Country_percentage_dict[country] = [AS_percentage_dict[AS]]
        country_vuln_ranking = dict(map(lambda x: (x[0], (sum(x[1])/len(x[1]))), Country_percentage_dict.items()))
        print("Country Vulnerability Ranking: Completed!")
        return country_vuln_ranking

    def compute_AS_vuln_ranking_after_hijack(self, sim_results, AS_vuln_list, n_most_common=1000):
        print("AS Vulnerability Ranking: In Progress ...")
        AS_counter_dict = dict(Counter([item for sublist in AS_vuln_list for item in sublist]).most_common(n_most_common))
        AS_percentage_dict = dict(map(lambda x: (x[0], self.vulnerability_percentage(x[1], len(sim_results))), AS_counter_dict.items()))
        print("AS Vulnerability Ranking: Completed!")
        return AS_percentage_dict


    def compute_AS_Country_vuln_ranking_after_hijack(self, simulation_uuid, conn):
        sim_results = self.fetch_sim_results(simulation_uuid, conn)
        asns_details_dict = self.fetch_AS_details(conn)
        AS_vuln_list = []
        for result in sim_results:
            AS_vuln_list.append(result['after_hijack']['dict_of_nodes_and_infected_paths_to_hijacker_prefix'].keys())
        as_vuln_ranking = self.compute_AS_vuln_ranking_after_hijack(sim_results, AS_vuln_list)
        country_vuln_ranking = self.compute_Country_vuln_ranking_after_hijack(sim_results, asns_details_dict, AS_vuln_list)
        return as_vuln_ranking, country_vuln_ranking

    def post(self):
        req_parser = reqparse.RequestParser()
        req_parser.add_argument('simulation_uuid', type=str, help="Simulation UUID, is required to retrieve all the results of the simulation and afterwards to compute the AS vulnerability Ranking for this simulation")
        req_data = req_parser.parse_args()

        simulation_uuid = req_data['simulation_uuid']

        '''
        create a connection to the database
        '''
        conn = self.connect_to_db(os.environ.get("DB_NAME"),
                                  os.environ.get("DB_USERNAME"),
                                  os.environ.get("DB_PASS"),
                                  os.environ.get("DB_IP"),
                                  os.environ.get("DB_PORT"))

        '''
        Fetch simulation data & produce the ranking
        '''
        as_vuln_ranking , country_vuln_ranking = self.compute_AS_Country_vuln_ranking_after_hijack(simulation_uuid, conn)

        '''
        close connection to database
        '''
        conn.close()

        return {"as_vuln_ranking": as_vuln_ranking, "country_vuln_ranking": country_vuln_ranking}