import json
import psycopg2
import requests
import operator


class NestedDict(dict):
    def __missing__(self, key):
        value = self[key] = type(self)()
        return value


def write_results(as_country_vuln_results_dict, file_path):
    with open(file_path, 'w') as json_file:
        json.dump(as_country_vuln_results_dict, json_file)


def connect_to_db(db_name, user, password, host, port):
    # establishing the connection
    conn = psycopg2.connect(
        database=db_name, user=user, password=password, host=host, port=port
    )

    '''
    psycopg2 is Python DB API-compliant, so the auto-commit feature is off by default. 
    We need to set conn.autocommit to True to commit any pending transaction to the database.
    '''
    conn.autocommit = True

    return conn


def fetch_all_sim_uuid(conn):
    # Creating a cursor object using the cursor() method
    cursor = conn.cursor()

    # Retrieving data
    cursor.execute('''SELECT simulation_id FROM BGP_HIJACKING_SIMULATIONS''')

    # return all rows from the table as json array
    return [r[0] for r in cursor.fetchall()]


def compute_num_of_all_sims(conn):
    # Creating a cursor object using the cursor() method
    cursor = conn.cursor()

    # Retrieving data
    cursor.execute('''SELECT num_of_simulations, num_of_repetitions FROM BGP_HIJACKING_SIMULATIONS''')
    return sum([r[0]*r[1] for r in cursor.fetchall()])



def generate_as_country_vuln_result(all_sim_uuids):
    as_country_vuln_results_dict = NestedDict()
    as_country_vuln_results_dict["as_vuln_ranking"] = {}
    as_country_vuln_results_dict["country_vuln_ranking"] = {}
    for simulation_id in all_sim_uuids:
        response = requests.get('http://127.0.0.1:5000/as_vulnerability_ranking', json={"simulation_uuid": simulation_id})
        #print(response.json())
        json_response = response.json()

        for AS in json_response["as_vuln_ranking"]:
            if AS not in as_country_vuln_results_dict["as_vuln_ranking"]:
                as_country_vuln_results_dict["as_vuln_ranking"][AS] = [json_response["as_vuln_ranking"][AS]]
            else:
                as_country_vuln_results_dict["as_vuln_ranking"][AS].append(json_response["as_vuln_ranking"][AS])

        for country in json_response["country_vuln_ranking"]:
            if country not in as_country_vuln_results_dict["country_vuln_ranking"]:
                as_country_vuln_results_dict["country_vuln_ranking"][country] = [json_response["country_vuln_ranking"][country]]
            else:
                as_country_vuln_results_dict["country_vuln_ranking"][country].append(json_response["country_vuln_ranking"][country])

    as_vuln_ranking = dict(map(lambda x: (x[0], (sum(x[1]) / len(all_sim_uuids))), as_country_vuln_results_dict["as_vuln_ranking"].items()))
    country_vuln_ranking = dict(map(lambda x: (x[0], (sum(x[1]) / len(all_sim_uuids))), as_country_vuln_results_dict["country_vuln_ranking"].items()))

    as_country_vuln_results_dict["as_vuln_ranking"] = dict(sorted(as_vuln_ranking.items(), key=operator.itemgetter(1), reverse=True))
    as_country_vuln_results_dict["country_vuln_ranking"] = dict(sorted(country_vuln_ranking.items(), key=operator.itemgetter(1), reverse=True))

    return as_country_vuln_results_dict


if __name__ == '__main__':
    '''
    create a connection to the database
    '''
    conn = connect_to_db("bgp_simulator", 'gepta', '1821', '127.0.0.1', '5432')

    all_sim_uuids = fetch_all_sim_uuid(conn)
    print(all_sim_uuids)

    as_country_vuln_results_dict = generate_as_country_vuln_result(all_sim_uuids)

    print(as_country_vuln_results_dict)
    write_results(as_country_vuln_results_dict, "as_country_vuln_ranking.json")

    '''
    close connection to database
    '''
    conn.close()